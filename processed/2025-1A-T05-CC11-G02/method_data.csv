file_path,class_name,name,doc_comment,source_code,references
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/cli_run/generate_embedding.py,,load_data,,"def load_data():
    """"""Carrega os dados do arquivo JSON.""""""
    with open(DATA_FILE, ""r"", encoding=""utf-8"") as f:
        data = json.load(f)
    return data",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/cli_run/generate_embedding.py,,extract_documents_from_data,"""""""Carrega os dados do arquivo JSON.""""""","def extract_documents_from_data(data):
    print(""entrouuuu"")
    """"""
    Recebe os dados (lista de mercados) e retorna uma lista de tuplas,
    onde cada tupla cont√©m as informa√ß√µes do produto necess√°rias para o banco de dados.
    """"""
    docs = []
    for market in data:
        market_name = market.get(""nome_mercado"", """")
        for produto in market.get(""produtos"", []):
            nome_produto = produto.get(""nome_produto"", """")
            descricao = produto.get(""descricao"", """").strip()
            preco = produto.get(""preco"", 0.0)
            marca = produto.get(""marca"", """")
            categoria = produto.get(""categoria"", """")
            
            # Criamos o texto para gerar o embedding apenas com o nome do produto
            text_for_embedding = nome_produto
            
            docs.append({
                'product': nome_produto,
                'description': descricao,
                'price': preco,
                'brand': marca,
                'category': categoria,
                'market_name': market_name,
                'text_for_embedding': text_for_embedding
            })
    return docs",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/cli_run/generate_embedding.py,,store_embeddings,"""""""Carrega os dados do arquivo JSON.""""""
""""""
    Recebe os dados (lista de mercados) e retorna uma lista de tuplas,
    onde cada tupla cont√©m as informa√ß√µes do produto necess√°rias para o banco de dados.
    """"""","def store_embeddings():
    """"""Carrega os dados do JSON, gera as embeddings para cada documento e armazena em SQLite.""""""
    if not os.getenv(""OPENAI_API_KEY""):
        print(""Error: Please set the OPENAI_API_KEY environment variable in your .env file."")
        return

    db_manager.create_tables()
    print(""entrou1"")
    data = load_data()
    documents = extract_documents_from_data(data)
    
    for doc in documents:
        print(f""Computing embedding for: {doc['product'][:50]}..."")
        embedding = compute_embedding.compute_embedding(doc['text_for_embedding'])
        
        db_manager.insert_document(
            product=doc['product'],
            product_embedding=embedding,
            description=doc['description'],
            price=doc['price'],
            brand=doc['brand'],
            category=doc['category'],
            market_name=doc['market_name']
        )
    
    print(""All embeddings stored in"", db_manager.db_file)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/cli_run/generate_embedding.py,,load_embeddings_from_db,"""""""Carrega os dados do arquivo JSON.""""""
""""""
    Recebe os dados (lista de mercados) e retorna uma lista de tuplas,
    onde cada tupla cont√©m as informa√ß√µes do produto necess√°rias para o banco de dados.
    """"""
""""""Carrega os dados do JSON, gera as embeddings para cada documento e armazena em SQLite.""""""","def load_embeddings_from_db():
    """"""Recupera todos os documentos e suas embeddings armazenadas no banco de dados SQLite.""""""
    return db_manager.get_all_documents()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/cli_run/generate_embedding.py,,main,"""""""Carrega os dados do arquivo JSON.""""""
""""""
    Recebe os dados (lista de mercados) e retorna uma lista de tuplas,
    onde cada tupla cont√©m as informa√ß√µes do produto necess√°rias para o banco de dados.
    """"""
""""""Carrega os dados do JSON, gera as embeddings para cada documento e armazena em SQLite.""""""
""""""Recupera todos os documentos e suas embeddings armazenadas no banco de dados SQLite.""""""","def main():
    """"""Fun√ß√£o principal para gerar embeddings.""""""
    if not os.getenv(""OPENAI_API_KEY""):
        print(""Error: Please set the OPENAI_API_KEY environment variable in your .env file."")
        return

    print(""\nüîÑ Iniciando gera√ß√£o de embeddings...\n"")
    print(""="" * 50)
    
    store_embeddings()
    print(""\n‚ú® Processo finalizado!"")",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/llms/prompt/impl/openai_impl.py,GPTImpl,__init__,,"def __init__(self, instruction):
        self.instruction = instruction",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/llms/prompt/impl/openai_impl.py,GPTImpl,getInstruction,,"def getInstruction(self):
        
        system_prompt = f""""""
            Voc√™ √© um assistente que converte listas de compras em formato JSON.
                Voc√™ deve corrigir erros de digita√ß√£o e de escrita.
                Converta a lista de compras fornecida em um array JSON onde cada item tem:
                  - name: nome do produto
                  - category: categoria do produto (se especificada)
                  - brand: marca do produto (se especificada)
                  - details: detalhes adicionais do produto (se especificados)
            """"""

        user_prompt = f""{self.instruction}""

        client = GPTClient()
        
        return client.getInstruction (system_prompt, user_prompt)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/llms/prompt/client/openai_client.py,GPTClient,__init__,,"def __init__(self,model=""gpt-3.5-turbo"",temperature=0.7):
        self.api_key = os.getenv(""OPENAI_API_KEY"")
        self.model = model
        self.temperature = temperature
        self.client = openai.OpenAI(api_key=os.getenv(""OPENAI_API_KEY""))",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/llms/prompt/client/openai_client.py,GPTClient,getInstruction,,"def getInstruction(self, system_prompt, user_prompt):

        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {""role"": ""system"", ""content"": system_prompt},
                {""role"": ""user"", ""content"": user_prompt}
            ],
            temperature=self.temperature,
        )
        
        return response.choices[0].message.content",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,__init__,"""""""Gerenciador de opera√ß√µes do banco de dados SQLite.""""""","def __init__(self, db_file: str = ""embeddings.db""):
        db_dir = os.path.join(os.path.dirname(__file__), ""../database"")
        # Create the directory if it doesn't exist
        os.makedirs(db_dir, exist_ok=True)
        self.db_file = os.path.join(db_dir, db_file)
        # self.db_file = db_file",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,_get_connection,,"def _get_connection(self) -> sqlite3.Connection:
        """"""Retorna uma conex√£o com o banco de dados.""""""
        return sqlite3.connect(self.db_file)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,create_tables,"""""""Retorna uma conex√£o com o banco de dados.""""""","def create_tables(self) -> None:
        """"""Cria as tabelas necess√°rias no banco de dados.""""""
        conn = self._get_connection()
        try:
            c = conn.cursor()
            c.execute('''
                CREATE TABLE IF NOT EXISTS documents (
                    id INTEGER PRIMARY KEY,
                    product TEXT,
                    product_embedding TEXT,
                    description TEXT,
                    price REAL,
                    brand TEXT,
                    category TEXT,
                    market_name TEXT
                )
            ''')
            conn.commit()
        finally:
            conn.close()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,insert_document,"""""""Retorna uma conex√£o com o banco de dados.""""""
""""""Cria as tabelas necess√°rias no banco de dados.""""""","def insert_document(self, product: str, product_embedding: List[float], description: str, 
                       price: float, brand: str, category: str, market_name: str) -> None:
        """"""
        Insere um novo documento com seus dados no banco de dados.
        
        Args:
            product: Nome do produto
            product_embedding: Lista de floats representando a embedding do produto
            description: Descri√ß√£o do produto
            price: Pre√ßo do produto
            brand: Marca do produto
            category: Categoria do produto
            market_name: Nome do mercado
        """"""
        conn = self._get_connection()
        try:
            c = conn.cursor()
            embedding_str = json.dumps(product_embedding)
            c.execute(""""""
                INSERT INTO documents (product, product_embedding, description, price, brand, category, market_name) 
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """""", (product, embedding_str, description, price, brand, category, market_name))
            conn.commit()
        finally:
            conn.close()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,get_all_documents,"""""""Retorna uma conex√£o com o banco de dados.""""""
""""""Cria as tabelas necess√°rias no banco de dados.""""""
""""""
        Insere um novo documento com seus dados no banco de dados.
        
        Args:
            product: Nome do produto
            product_embedding: Lista de floats representando a embedding do produto
            description: Descri√ß√£o do produto
            price: Pre√ßo do produto
            brand: Marca do produto
            category: Categoria do produto
            market_name: Nome do mercado
        """"""","def get_all_documents(self) -> List[Tuple[int, str, List[float], str, float, str, str, str]]:
        """"""
        Recupera todos os documentos do banco de dados.
        
        Returns:
            Lista de tuplas (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
        """"""
        conn = self._get_connection()
        try:
            c = conn.cursor()
            c.execute(""SELECT * FROM documents"")
            rows = c.fetchall()
            
            documents = []
            for row in rows:
                doc_id, product, embedding_str, description, price, brand, category, market_name = row
                embedding = json.loads(embedding_str)
                documents.append((doc_id, product, embedding, description, price, brand, category, market_name))
            return documents
        finally:
            conn.close()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,clear_documents,"""""""Retorna uma conex√£o com o banco de dados.""""""
""""""Cria as tabelas necess√°rias no banco de dados.""""""
""""""
        Insere um novo documento com seus dados no banco de dados.
        
        Args:
            product: Nome do produto
            product_embedding: Lista de floats representando a embedding do produto
            description: Descri√ß√£o do produto
            price: Pre√ßo do produto
            brand: Marca do produto
            category: Categoria do produto
            market_name: Nome do mercado
        """"""
""""""
        Recupera todos os documentos do banco de dados.
        
        Returns:
            Lista de tuplas (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
        """"""","def clear_documents(self) -> None:
        """"""Remove todos os documentos do banco de dados.""""""
        conn = self._get_connection()
        try:
            c = conn.cursor()
            c.execute(""DELETE FROM documents"")
            conn.commit()
        finally:
            conn.close()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/infrastructure/database/sqlite_manager.py,DBManager,get_document_by_id,"""""""Retorna uma conex√£o com o banco de dados.""""""
""""""Cria as tabelas necess√°rias no banco de dados.""""""
""""""
        Insere um novo documento com seus dados no banco de dados.
        
        Args:
            product: Nome do produto
            product_embedding: Lista de floats representando a embedding do produto
            description: Descri√ß√£o do produto
            price: Pre√ßo do produto
            brand: Marca do produto
            category: Categoria do produto
            market_name: Nome do mercado
        """"""
""""""
        Recupera todos os documentos do banco de dados.
        
        Returns:
            Lista de tuplas (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
        """"""
""""""Remove todos os documentos do banco de dados.""""""","def get_document_by_id(self, doc_id: int) -> Optional[Tuple[int, str, List[float], str, float, str, str, str]]:
        """"""
        Recupera um documento espec√≠fico pelo ID.
        
        Args:
            doc_id: ID do documento

        Returns:
            Tupla (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado) ou None se n√£o encontrado
        """"""
        conn = self._get_connection()
        try:
            c = conn.cursor()
            c.execute(""SELECT * FROM documents WHERE id = ?"", (doc_id,))
            row = c.fetchone()
            
            if row:
                doc_id, product, embedding_str, description, price, brand, category, market_name = row
                embedding = json.loads(embedding_str)
                return (doc_id, product, embedding, description, price, brand, category, market_name)
            return None
        finally:
            conn.close()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/routes/v1/groucery_routes.py,,list_route,,"def list_route():
    
    print(""entrou"")
    data = request.get_json() 

    message = data[""message""]
    
    result = GenerateGroceryListUseCase(message).execute()
    print(""saiu ->"", result)
    return jsonify({""ingredients"": result})",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/routes/v1/groucery_routes.py,,buy,,"def buy():
    data = request.get_json()
    message = data[""message""]
    
    return jsonify({""message"": ""Compra realizada com sucesso!""})",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/usecases/generate_grocery_list.py,GenerateGroceryListUseCase,__init__,,"def __init__ (self, instruction):
        self.instruction = instruction",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/usecases/generate_grocery_list.py,GenerateGroceryListUseCase,execute,,"def execute(self):
        gpt = GPTImpl(self.instruction)
        list = gpt.getInstruction()
        print(""list ->"", list)
        return ProductSearch().search(list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/product_search_service.py,ProductSearch,__init__,,"def __init__(self):
        pass",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/product_search_service.py,ProductSearch,parse_document_text,,"def parse_document_text(self,doc):
        """"""
        Converte os dados do documento em um dicion√°rio estruturado.
        
        Args:
            doc: Tupla contendo os dados do documento (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
            
        Returns:
            Dict com as informa√ß√µes parseadas
        """"""
        return {
            ""Produto"": doc[1],
            ""Descri√ß√£o"": doc[3],
            ""Pre√ßo"": f""R$ {doc[4]:.2f}"",
            ""Marca"": doc[5],
            ""Categoria"": doc[6],
            ""Mercado"": doc[7]
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/product_search_service.py,ProductSearch,load_embeddings_from_db,"""""""
        Converte os dados do documento em um dicion√°rio estruturado.
        
        Args:
            doc: Tupla contendo os dados do documento (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
            
        Returns:
            Dict com as informa√ß√µes parseadas
        """"""","def load_embeddings_from_db(self):
        """"""Recupera todos os documentos e suas embeddings armazenadas no banco de dados SQLite.""""""
        return db_manager.get_all_documents()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/product_search_service.py,ProductSearch,normalize_text,"""""""
        Converte os dados do documento em um dicion√°rio estruturado.
        
        Args:
            doc: Tupla contendo os dados do documento (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
            
        Returns:
            Dict com as informa√ß√µes parseadas
        """"""
""""""Recupera todos os documentos e suas embeddings armazenadas no banco de dados SQLite.""""""","def normalize_text(self,text):
        """"""
        Normaliza o texto removendo acentos e convertendo para min√∫sculas.
        
        Args:
            text: Texto a ser normalizado
            
        Returns:
            Texto normalizado
        """"""
        import unicodedata
        
        # Remove acentos
        normalized = unicodedata.normalize('NFKD', text)
        normalized = ''.join(c for c in normalized if not unicodedata.combining(c))
        
        # Converte para min√∫sculas
        return normalized.lower()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/product_search_service.py,ProductSearch,search,"""""""
        Converte os dados do documento em um dicion√°rio estruturado.
        
        Args:
            doc: Tupla contendo os dados do documento (id, produto, embedding, descri√ß√£o, pre√ßo, marca, categoria, mercado)
            
        Returns:
            Dict com as informa√ß√µes parseadas
        """"""
""""""Recupera todos os documentos e suas embeddings armazenadas no banco de dados SQLite.""""""
""""""
        Normaliza o texto removendo acentos e convertendo para min√∫sculas.
        
        Args:
            text: Texto a ser normalizado
            
        Returns:
            Texto normalizado
        """"""","def search(self,list):
        print(""\nüîÑ Inicializando sistema de busca de produtos...\n"")
        print(""="" * 50)
        
        # Carrega os documentos com embeddings do BD
        documents = self.load_embeddings_from_db()
        if not documents:
            print(""‚ùå Erro: N√£o h√° embeddings no banco de dados."")
            print(""üí° Execute primeiro: python generate_embedding.py"")
            return

        # Recebe a lista de compras do usu√°rio
        print(""üõí Bem-vindo ao assistente de compras!"")
        print(""="" * 50)
        print(list,""olha lista"")
        
        shopping_items = eval(list)

        print(shopping_items,""olha shopping_items"")

        results = {}
        print(""\nüîç Buscando produtos nos mercados..."")
        print(""="" * 50)
        
        # Para cada item da lista de compras, busca produtos similares no BD
        for item in shopping_items:
            product_name = item.get(""name"", """").strip()
            if not product_name:
                continue
            
            category = item.get(""category"", """").lower()
            brand = item.get(""brand"", """").lower()
            
            normalized_query = self.normalize_text(product_name)
            print(f""\nüì¶ Analisando: '{product_name}'"")
            print(f""üî§ Query de busca normalizada: '{normalized_query}'"")
            
            # Primeiro filtro: busca por substring no nome do produto
            filtered_products = []
            for doc in documents:
                normalized_product = self.normalize_text(doc[1])  # doc[1] √© o nome do produto
                if normalized_query in normalized_product:
                    filtered_products.append(doc)
            
            print(f""üéØ Produtos encontrados na busca inicial: {len(filtered_products)}"")
            
            # Se encontrou produtos, aplica a similaridade de cosseno
            matching_products = []
            seen_products = set()  # Para controlar duplicatas
            
            if filtered_products:
                query_embedding = compute_embedding.compute_embedding(product_name)
                
                # Aplica similaridade de cosseno nos produtos filtrados
                for doc in filtered_products:
                    sim = cosine_similarity(query_embedding, doc[2])
                    # Verifica similaridade e filtros adicionais
                    if sim >= 0.75:
                        # Aplica filtros de categoria e marca se especificados
                        doc_category = doc[6].lower() if doc[6] else """"
                        doc_brand = doc[5].lower() if doc[5] else """"
                        
                        if (not category or category in doc_category) and \
                        (not brand or brand in doc_brand):
                            parsed = self.parse_document_text(doc)
                            product_key = (doc[1], doc[4], doc[7])  # produto, pre√ßo e mercado como chave √∫nica
                            
                            # Evita duplicatas
                            if product_key not in seen_products:
                                seen_products.add(product_key)
                                matching_products.append({
                                    ""nome"": parsed[""Produto""],
                                    ""descricao"": parsed[""Descri√ß√£o""],
                                    ""marca"": parsed[""Marca""],
                                    ""categoria"": parsed[""Categoria""],
                                    ""valor"": parsed[""Pre√ßo""],
                                    ""mercado"": parsed[""Mercado""],
                                    ""similaridade"": sim
                                })
            
            # Ordena os produtos por similaridade
            matching_products.sort(key=lambda x: x[""similaridade""], reverse=True)
            
            results[product_name] = matching_products
            print(f""‚úÖ Encontrados {len(matching_products)} produtos similares ap√≥s filtros"")

        print(""\nüéØ Resultado final da busca:"")
        print(""="" * 50)
        print(json.dumps(results, ensure_ascii=False, indent=2))
        print(""\n‚ú® Busca finalizada!"")
        return results",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/similarity_search.py,,cosine_similarity,,"def cosine_similarity(a, b):
    """"""Calcula a similaridade cosseno entre dois vetores a e b.""""""
    a = np.array(a)
    b = np.array(b)
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b) + 1e-10)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/compute_embedding.py,ComputeEmbedding,__init__,,"def __init__(self):
        self.client = OpenAI()",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/backend/src/services/compute_embedding.py,ComputeEmbedding,compute_embedding,,"def compute_embedding(self, text):
        """"""Chama a API do OpenAI para computar a embedding para um texto dado.""""""
        response = self.client.embeddings.create(
            input=text,
            model=""text-embedding-ada-002""
        )
        embedding = response.data[0].embedding
        return embedding",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Store,from_json,,"def from_json(cls, data):
        """"""Create a Store instance from a dictionary.""""""
        return cls(
            name=data['name'],
            address=data['address']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Store,to_json,"""""""
    This class represents a store in the database.

    A store is a place that sells products. Each store has a name and an address, and it can have multiple products 
    associated with it. The relationship between a store and products is one-to-many, meaning each store can have 
    many products, but each product is associated with only one store.

    Attributes:
        id (int): The unique identifier for the store.
        name (str): The name of the store.
        address (str): The physical address of the store.

    Methods:
        to_json: Converts the Store instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a Store instance from a dictionary.""""""","def to_json(self):
        """"""Convert the Store object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""name"": self.name,
            ""address"": self.address
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Label,from_json,,"def from_json(cls, data):
        """"""Create a Label instance from a dictionary.""""""
        return cls(
            name=data['name']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Label,to_json,"""""""
    This class represents a label in the database.

    A label is a tag or category that can be associated with multiple products. Each label has a name, and products
    can have multiple labels. The relationship between labels and products is many-to-many, facilitated by the 
    `LabelProd` association table.

    Attributes:
        id (int): The unique identifier for the label.
        name (str): The name of the label (e.g., ""Organic"", ""Sale"").

    Methods:
        to_json: Converts the Label instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a Label instance from a dictionary.""""""","def to_json(self):
        """"""Convert the Label object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""name"": self.name
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Restriction,from_json,,"def from_json(cls, data):
        """"""Create a Restriction instance from a dictionary.""""""
        return cls(
            name=data['name']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Restriction,to_json,"""""""
    This class represents a restriction in the database.

    A restriction is a condition that can be applied to products, such as age restrictions or food restrictions.
    Each restriction has a name, and products can have multiple restrictions. The relationship between restrictions 
    and products is many-to-many, facilitated by the `RestProd` association table.

    Attributes:
        id (int): The unique identifier for the restriction.
        name (str): The name of the restriction (e.g., ""18+ Only"", ""No International Shipping"").

    Methods:
        to_json: Converts the Restriction instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a Restriction instance from a dictionary.""""""","def to_json(self):
        """"""Convert the Restriction object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""name"": self.name
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Brand,from_json,,"def from_json(cls, data):
        """"""Create a Brand instance from a dictionary.""""""
        return cls(
            name=data['name']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Brand,to_json,"""""""
    This class represents a brand in the database.

    A brand is a manufacturer or company that produces products. Each brand has a name, and products can be associated
    with a specific brand. The relationship between a brand and products is one-to-many, meaning each brand can have 
    many products, but each product can belong to only one brand.

    Attributes:
        id (int): The unique identifier for the brand.
        name (str): The name of the brand (e.g., ""Nike"", ""Apple"").

    Methods:
        to_json: Converts the Brand instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a Brand instance from a dictionary.""""""","def to_json(self):
        """"""Convert the Brand object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""name"": self.name
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Product,from_json,,"def from_json(cls, data):
        """"""Create a Product instance from a dictionary.""""""
        return cls(
            name=data['name'],
            price=data['price'],
            description=data['description'][:249],
            id_store=data['id_store'],
            id_brand=data['id_brand']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,Product,to_json,"""""""
    This class represents a product in the database.

    A product is an item that can be sold by a store, and each product has attributes like a name, price, and 
    description. A product can belong to a store and a brand, and it can have multiple labels and restrictions. 

    Attributes:
        id (int): The unique identifier for the product.
        name (str): The name of the product.
        price (float): The price of the product.
        description (str): A description of the product.
        id_store (int): The ID of the store that owns the product.
        id_brand (int): The ID of the brand associated with the product.

    Methods:
        to_json: Converts the Product instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a Product instance from a dictionary.""""""","def to_json(self):
        """"""Convert the Product object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""name"": self.name,
            ""price"": self.price,
            ""description"": self.description,
            ""id_store"": self.id_store,
            ""id_brand"": self.id_brand
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,LabelProd,from_json,,"def from_json(cls, data):
        """"""Create a LabelProd instance from a dictionary.""""""
        return cls(
            id_prod=data['id_prod'],
            id_label=data['id_label']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,LabelProd,to_json,"""""""
    This class represents the association between products and labels in the database.

    This is a many-to-many relationship between products and labels. A product can have multiple labels, and a label 
    can be associated with multiple products. This class facilitates that relationship.

    Attributes:
        id (int): The unique identifier for the association.
        id_prod (int): The ID of the product.
        id_label (int): The ID of the label.

    Methods:
        to_json: Converts the LabelProd instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a LabelProd instance from a dictionary.""""""","def to_json(self):
        """"""Convert the LabelProd object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""id_prod"": self.id_prod,
            ""id_label"": self.id_label
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,RestProd,from_json,,"def from_json(cls, data):
        """"""Create a RestProd instance from a dictionary.""""""
        return cls(
            id_prod=data['id_prod'],
            id_rest=data['id_rest']
        )",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/models.py,RestProd,to_json,"""""""
    This class represents the association between products and restrictions in the database.

    This is a many-to-many relationship between products and restrictions. A product can have multiple restrictions, 
    and a restriction can be associated with multiple products. This class facilitates that relationship.

    Attributes:
        id (int): The unique identifier for the association.
        id_prod (int): The ID of the product.
        id_rest (int): The ID of the restriction.

    Methods:
        to_json: Converts the RestProd instance to a dictionary that can be easily serialized to JSON.
    """"""
""""""Create a RestProd instance from a dictionary.""""""","def to_json(self):
        """"""Convert the RestProd object to a dictionary that can be easily serialized to JSON.""""""
        return {
            ""id"": self.id,
            ""id_prod"": self.id_prod,
            ""id_rest"": self.id_rest
        }",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/__init__.py,,get_app,,"def get_app():
    print(DB_URL)
    app = Flask(__name__)

    app.config['SQLALCHEMY_DATABASE_URI'] = DB_URL
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)

    return app",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,ping,,"def ping():
    """"""
    Ping the API.

    This endpoint returns a simple ""Hello World"" message, confirming that the API is up and running.

    Returns:
        JSON: A response containing a message ""Hello World from the API"".
    """"""
    return jsonify({""message"": ""Hello World from the API""}), 200",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_product,,"def create_product():
    """"""
    Create a new product.

    This endpoint allows you to create a new product by providing the following details in the request body:
    - name: Name of the product
    - price: Price of the product
    - id_store: ID of the store the product belongs to
    - id_brand: (Optional) ID of the brand the product belongs to

    Returns:
        JSON: A message confirming product creation and the ID of the newly created product.
    """"""
    data = request.get_json()
    new_product = Product.from_json(data)
    db.session.add(new_product)
    db.session.commit()
    return jsonify({""message"": ""Product created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_products_batch,,"def create_products_batch():
    """"""
    Create multiple new products in a batch.

    This endpoint allows you to create multiple products by providing an array of product details in the request body.
    Each product object should contain the following details:
    - name: Name of the product
    - price: Price of the product
    - id_store: ID of the store the product belongs to
    - id_brand: (Optional) ID of the brand the product belongs to

    Returns:
        JSON: A message confirming the creation of products and a list of the newly created product IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of products""}), 400

    for product_data in data:
        try:
            new_product = Product.from_json(product_data)
            db.session.add(new_product)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Products created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_products,,"def get_products():
    """"""
    Get a list of all products.

    This endpoint retrieves all products from the database and returns them in a JSON format. Each product
    is represented with its id, name, and price.

    Returns:
        JSON: A list of dictionaries containing the id, name, and price of each product.
    """"""
    products = Product.query.all()
    product_list = [p.to_json() for p in products]
    return jsonify(product_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_product,,"def get_product(id):
    """"""
    Get details of a specific product by ID.

    Args:
        id (int): The ID of the product to be retrieved.

    Returns:
        JSON: A dictionary containing the product's id, name, price, store id, brand id, labels, and restrictions.
    """"""
    product = Product.query.get(id)
    if product:
        return jsonify(product.to_json())
    return jsonify({""message"": ""Product not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_product,,"def update_product(id):
    """"""
    Update an existing product.

    This endpoint allows you to update the details of a product by providing the following fields in the request body:
    - name: New name of the product
    - price: New price of the product

    Args:
        id (int): The ID of the product to be updated.

    Returns:
        JSON: A message confirming that the product was updated, or an error message if the product was not found.
    """"""
    product = Product.query.get(id)
    if product:
        data = request.get_json()
        product.name = data['name']
        product.price = data['price']
        db.session.commit()
        return jsonify({""message"": ""Product updated""})
    return jsonify({""message"": ""Product not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_product,,"def delete_product(id):
    """"""
    Delete a product.

    This endpoint allows you to delete an existing product by providing the product's ID in the URL.

    Args:
        id (int): The ID of the product to be deleted.

    Returns:
        JSON: A message confirming that the product was deleted, or an error message if the product was not found.
    """"""
    product = Product.query.get(id)
    if product:
        db.session.delete(product)
        db.session.commit()
        return jsonify({""message"": ""Product deleted""})
    return jsonify({""message"": ""Product not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_label_prod,,"def create_label_prod():
    """"""
    Create a new label-product relation.

    This endpoint allows you to create a new relation between a product and a label by providing the following details:
    - id_prod: ID of the product
    - id_label: ID of the label

    Returns:
        JSON: A message confirming the creation of the label-product relation and the ID of the newly created relation.
    """"""
    data = request.get_json()
    new_label_prod = LabelProd.from_json(data)
    db.session.add(new_label_prod)
    db.session.commit()
    return jsonify({""message"": ""Label-Product relation created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_label_prods_batch,,"def create_label_prods_batch():
    """"""
    Create multiple new label-product relations in a batch.

    This endpoint allows you to create multiple label-product relations by providing an array of relation details in the request body.
    Each relation object should contain the following details:
    - id_prod: ID of the product
    - id_label: ID of the label

    Returns:
        JSON: A message confirming the creation of label-product relations and a list of the newly created relation IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of label-product relations""}), 400

    for relation_data in data:
        try:
            new_label_prod = LabelProd.from_json(relation_data)
            db.session.add(new_label_prod)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}, Got {relation_data}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Label-Product relations created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_label_prods,,"def get_label_prods():
    """"""
    Get a list of all label-product relations.

    This endpoint retrieves all label-product relations from the database and returns them in a JSON format.

    Returns:
        JSON: A list of dictionaries containing the id, id_prod, and id_label of each relation.
    """"""
    label_prods = LabelProd.query.all()
    label_prod_list = [lp.to_json() for lp in label_prods]
    return jsonify(label_prod_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_label_prod,,"def get_label_prod(id):
    """"""
    Get a label-product relation by ID.

    This endpoint retrieves a specific label-product relation by its ID.

    Args:
        id (int): The ID of the label-product relation to retrieve.

    Returns:
        JSON: The details of the label-product relation if found, or an error message if not.
    """"""
    label_prod = LabelProd.query.get(id)
    if label_prod:
        return jsonify(label_prod.to_json())
    return jsonify({""message"": ""Label-Product relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_label_prod,,"def update_label_prod(id):
    """"""
    Update an existing label-product relation.

    This endpoint allows you to update the details of an existing label-product relation by providing the following fields:
    - id_prod: New product ID
    - id_label: New label ID

    Args:
        id (int): The ID of the label-product relation to update.

    Returns:
        JSON: A message confirming the update, or an error message if the relation was not found.
    """"""
    label_prod = LabelProd.query.get(id)
    if label_prod:
        data = request.get_json()
        label_prod.id_prod = data['id_prod']
        label_prod.id_label = data['id_label']
        db.session.commit()
        return jsonify({""message"": ""Label-Product relation updated""})
    return jsonify({""message"": ""Label-Product relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_label_prod,,"def delete_label_prod(id):
    """"""
    Delete a label-product relation.

    This endpoint allows you to delete a label-product relation by providing the relation's ID.

    Args:
        id (int): The ID of the label-product relation to delete.

    Returns:
        JSON: A message confirming the deletion, or an error message if the relation was not found.
    """"""
    label_prod = LabelProd.query.get(id)
    if label_prod:
        db.session.delete(label_prod)
        db.session.commit()
        return jsonify({""message"": ""Label-Product relation deleted""})
    return jsonify({""message"": ""Label-Product relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_rest_prod,,"def create_rest_prod():
    """"""
    Create a new product-restriction relation.

    This endpoint allows you to create a new relation between a product and a restriction by providing the following details:
    - id_prod: ID of the product
    - id_rest: ID of the restriction

    Returns:
        JSON: A message confirming the creation of the product-restriction relation and the ID of the newly created relation.
    """"""
    data = request.get_json()
    new_rest_prod = RestProd.from_json(data)
    db.session.add(new_rest_prod)
    db.session.commit()
    return jsonify({""message"": ""Product-Restriction relation created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_rest_prods,,"def get_rest_prods():
    """"""
    Get a list of all product-restriction relations.

    This endpoint retrieves all product-restriction relations from the database and returns them in a JSON format.

    Returns:
        JSON: A list of dictionaries containing the id, id_prod, and id_rest of each relation.
    """"""
    rest_prods = RestProd.query.all()
    rest_prod_list = [rp.to_json() for rp in rest_prods]
    return jsonify(rest_prod_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_rest_prod,,"def get_rest_prod(id):
    """"""
    Get a product-restriction relation by ID.

    This endpoint retrieves a specific product-restriction relation by its ID.

    Args:
        id (int): The ID of the product-restriction relation to retrieve.

    Returns:
        JSON: The details of the product-restriction relation if found, or an error message if not.
    """"""
    rest_prod = RestProd.query.get(id)
    if rest_prod:
        return jsonify(rest_prod.to_json())
    return jsonify({""message"": ""Product-Restriction relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_rest_prod,,"def update_rest_prod(id):
    """"""
    Update an existing product-restriction relation.

    This endpoint allows you to update the details of an existing product-restriction relation by providing the following fields:
    - id_prod: New product ID
    - id_rest: New restriction ID

    Args:
        id (int): The ID of the product-restriction relation to update.

    Returns:
        JSON: A message confirming the update, or an error message if the relation was not found.
    """"""
    rest_prod = RestProd.query.get(id)
    if rest_prod:
        data = request.get_json()
        rest_prod.id_prod = data['id_prod']
        rest_prod.id_rest = data['id_rest']
        db.session.commit()
        return jsonify({""message"": ""Product-Restriction relation updated""})
    return jsonify({""message"": ""Product-Restriction relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_rest_prod,,"def delete_rest_prod(id):
    """"""
    Delete a product-restriction relation.

    This endpoint allows you to delete a product-restriction relation by providing the relation's ID.

    Args:
        id (int): The ID of the product-restriction relation to delete.

    Returns:
        JSON: A message confirming the deletion, or an error message if the relation was not found.
    """"""
    rest_prod = RestProd.query.get(id)
    if rest_prod:
        db.session.delete(rest_prod)
        db.session.commit()
        return jsonify({""message"": ""Product-Restriction relation deleted""})
    return jsonify({""message"": ""Product-Restriction relation not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_store,,"def create_store():
    """"""
    Create a new store.

    This endpoint allows you to create a new store by providing the following details in the request body:
    - name: Name of the store
    - address: Address of the store

    Returns:
        JSON: A message confirming store creation and the ID of the newly created store.
    """"""
    data = request.get_json()
    new_store = Store.from_json(data)
    db.session.add(new_store)
    db.session.commit()
    return jsonify({""message"": ""Store created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_stores_batch,,"def create_stores_batch():
    """"""
    Create multiple new stores in a batch.

    This endpoint allows you to create multiple stores by providing an array of store details in the request body.
    Each store object should contain the following details:
    - name: Name of the store
    - address: Address of the store

    Returns:
        JSON: A message confirming the creation of stores and a list of the newly created store IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of stores""}), 400

    for store_data in data:
        try:
            new_store = Store.from_json(store_data)
            db.session.add(new_store)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}, Got {store_data}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Stores created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_stores,,"def get_stores():
    """"""
    Get a list of all stores.

    This endpoint retrieves all stores from the database and returns them in a JSON format.
    Each store is represented with its id, name, and address.

    Returns:
        JSON: A list of dictionaries containing the id, name, and address of each store.
    """"""
    stores = Store.query.all()
    store_list = [s.to_json() for s in stores]
    return jsonify(store_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_store_by_name,,"def get_store_by_name():
    """"""
    Get details of a specific store by name (case-insensitive).

    Args:
        name (str): The name of the store to be retrieved. This will be passed as a query parameter.

    Returns:
        JSON: A dictionary containing the store's id, name, and address, or an error message if not found.
    """"""
    name = request.args.get('name')

    if not name:
        return jsonify({""message"": ""Store name is required""}), 400

    store = Store.query.filter(Store.name.ilike(name)).first()

    if store:
        return jsonify(store.to_json())
    return jsonify({""message"": ""Store not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_store,,"def get_store(id):
    """"""
    Get details of a specific store by ID.

    Args:
        id (int): The ID of the store to be retrieved.

    Returns:
        JSON: A dictionary containing the store's id, name, and address.
    """"""
    store = Store.query.get(id)
    if store:
        return jsonify({""id"": store.id, ""name"": store.name, ""address"": store.address})
    return jsonify({""message"": ""Store not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_store,,"def update_store(id):
    """"""
    Update the details of an existing store.

    This endpoint allows you to update the name and address of a store by providing the updated data in the request body.

    Args:
        id (int): The ID of the store to be updated.

    Returns:
        JSON: A message confirming that the store was updated, or an error message if the store was not found.
    """"""
    store = Store.query.get(id)
    if store:
        data = request.get_json()
        store.name = data['name']
        store.address = data['address']
        db.session.commit()
        return jsonify({""message"": ""Store updated""})
    return jsonify({""message"": ""Store not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_store,,"def delete_store(id):
    """"""
    Delete a store.

    This endpoint allows you to delete an existing store by providing the store's ID in the URL.

    Args:
        id (int): The ID of the store to be deleted.

    Returns:
        JSON: A message confirming that the store was deleted, or an error message if the store was not found.
    """"""
    store = Store.query.get(id)
    if store:
        db.session.delete(store)
        db.session.commit()
        return jsonify({""message"": ""Store deleted""})
    return jsonify({""message"": ""Store not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_label,,"def create_label():
    """"""
    Create a new label.

    This endpoint allows you to create a new label by providing the following details in the request body:
    - name: Name of the label

    Returns:
        JSON: A message confirming label creation and the ID of the newly created label.
    """"""
    data = request.get_json()
    new_label = Label.from_json(data)
    db.session.add(new_label)
    db.session.commit()
    return jsonify({""message"": ""Label created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_labels_batch,,"def create_labels_batch():
    """"""
    Create multiple new labels in a batch.

    This endpoint allows you to create multiple labels by providing an array of label details in the request body.
    Each label object should contain the following details:
    - name: Name of the label

    Returns:
        JSON: A message confirming the creation of labels and a list of the newly created label IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of labels""}), 400

    for label_data in data:
        try:
            new_label = Label.from_json(label_data)
            db.session.add(new_label)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Labels created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_labels,,"def get_labels():
    """"""
    Get a list of all labels.

    This endpoint retrieves all labels from the database and returns them in a JSON format.
    Each label is represented with its id and name.

    Returns:
        JSON: A list of dictionaries containing the id and name of each label.
    """"""
    labels = Label.query.all()
    label_list = [l.to_json() for l in labels]
    return jsonify(label_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_label,,"def get_label(id):
    """"""
    Get details of a specific label by ID.

    Args:
        id (int): The ID of the label to be retrieved.

    Returns:
        JSON: A dictionary containing the label's id and name.
    """"""
    label = Label.query.get(id)
    if label:
        return jsonify({""id"": label.id, ""name"": label.name})
    return jsonify({""message"": ""Label not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_label,,"def update_label(id):
    """"""
    Update the details of an existing label.

    This endpoint allows you to update the name of a label by providing the updated data in the request body.

    Args:
        id (int): The ID of the label to be updated.

    Returns:
        JSON: A message confirming that the label was updated, or an error message if the label was not found.
    """"""
    label = Label.query.get(id)
    if label:
        data = request.get_json()
        label.name = data['name']
        db.session.commit()
        return jsonify({""message"": ""Label updated""})
    return jsonify({""message"": ""Label not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_label,,"def delete_label(id):
    """"""
    Delete a label.

    This endpoint allows you to delete an existing label by providing the label's ID in the URL.

    Args:
        id (int): The ID of the label to be deleted.

    Returns:
        JSON: A message confirming that the label was deleted, or an error message if the label was not found.
    """"""
    label = Label.query.get(id)
    if label:
        db.session.delete(label)
        db.session.commit()
        return jsonify({""message"": ""Label deleted""})
    return jsonify({""message"": ""Label not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_brand,,"def create_brand():
    """"""
    Create a new brand.

    This endpoint allows you to create a new brand by providing the following details in the request body:
    - name: Name of the brand

    Returns:
        JSON: A message confirming brand creation and the ID of the newly created brand.
    """"""
    data = request.get_json()
    new_brand = Brand.from_json(data)
    db.session.add(new_brand)
    db.session.commit()
    return jsonify({""message"": ""Brand created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_brands_batch,,"def create_brands_batch():
    """"""
    Create multiple new brands in a batch.

    This endpoint allows you to create multiple brands by providing an array of brand details in the request body.
    Each brand object should contain the following details:
    - name: Name of the brand

    Returns:
        JSON: A message confirming the creation of brands and a list of the newly created brand IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of brands""}), 400

    for brand_data in data:
        try:
            new_brand = Brand.from_json(brand_data)
            db.session.add(new_brand)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Brands created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_brands,,"def get_brands():
    """"""
    Get a list of all brands.

    This endpoint retrieves all brands from the database and returns them in a JSON format.
    Each brand is represented with its id and name.

    Returns:
        JSON: A list of dictionaries containing the id and name of each brand.
    """"""
    brands = Brand.query.all()
    brand_list = [b.to_json() for b in brands]
    return jsonify(brand_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_brand,,"def get_brand(id):
    """"""
    Get details of a specific brand by ID.

    Args:
        id (int): The ID of the brand to be retrieved.

    Returns:
        JSON: A dictionary containing the brand's id and name.
    """"""
    brand = Brand.query.get(id)
    if brand:
        return jsonify(brand.to_json())
    return jsonify({""message"": ""Brand not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_brand_by_name,,"def get_brand_by_name():
    """"""
    Get details of a specific brand by name (case-insensitive).

    Args:
        name (str): The name of the brand to be retrieved. This will be passed as a query parameter.

    Returns:
        JSON: A dictionary containing the brand's id and name, or an error message if not found.
    """"""
    name = request.args.get('name')

    if not name:
        return jsonify({""message"": ""Brand name is required""}), 400

    brand = Brand.query.filter(Brand.name.ilike(name)).first()

    if brand:
        return jsonify(brand.to_json())
    return jsonify({""message"": ""Brand not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_brand,,"def update_brand(id):
    """"""
    Update the details of an existing brand.

    This endpoint allows you to update the name of a brand by providing the updated data in the request body.

    Args:
        id (int): The ID of the brand to be updated.

    Returns:
        JSON: A message confirming that the brand was updated, or an error message if the brand was not found.
    """"""
    brand = Brand.query.get(id)
    if brand:
        data = request.get_json()
        brand.name = data['name']
        db.session.commit()
        return jsonify({""message"": ""Brand updated""})
    return jsonify({""message"": ""Brand not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_brand,,"def delete_brand(id):
    """"""
    Delete a brand.

    This endpoint allows you to delete an existing brand by providing the brand's ID in the URL.

    Args:
        id (int): The ID of the brand to be deleted.

    Returns:
        JSON: A message confirming that the brand was deleted, or an error message if the brand was not found.
    """"""
    brand = Brand.query.get(id)
    if brand:
        db.session.delete(brand)
        db.session.commit()
        return jsonify({""message"": ""Brand deleted""})
    return jsonify({""message"": ""Brand not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_restriction,,"def create_restriction():
    """"""
    Create a new restriction.

    This endpoint allows you to create a new restriction by providing the following details in the request body:
    - name: The name of the restriction.

    Returns:
        JSON: A message confirming the creation of the restriction and the ID of the newly created restriction.
    """"""
    data = request.get_json()
    new_restriction = Restriction.from_json(data)
    db.session.add(new_restriction)
    db.session.commit()
    return jsonify({""message"": ""Restriction created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_restrictions,,"def get_restrictions():
    """"""
    Get a list of all restrictions.

    This endpoint retrieves all restrictions from the database and returns them in a JSON format.

    Returns:
        JSON: A list of dictionaries containing the id and name of each restriction.
    """"""
    restrictions = Restriction.query.all()
    restriction_list = [r.to_json() for r in restrictions]
    return jsonify(restriction_list)",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,create_restriction_batch,,"def create_restriction_batch():
    """"""
    Create multiple new restrictions in a batch.

    This endpoint allows you to create multiple restrictions by providing an array of restriction details in the request body.
    Each restriction object should contain the following details:
    - name: Name of the restriction

    Returns:
        JSON: A message confirming the creation of restrictions and a list of the newly created restriction IDs.
    """"""
    data = request.get_json()

    if not isinstance(data, list):
        return jsonify({""error"": ""Expected a list of restrictions""}), 400

    for restriction_data in data:
        try:
            new_restriction = Restriction.from_json(restriction_data)
            db.session.add(new_restriction)
        except KeyError as e:
            return jsonify({""error"": f""Missing required field: {str(e)}""}), 400

    db.session.commit()

    return jsonify({""message"": ""Restrictions created""}), 201",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,get_restriction,,"def get_restriction(id):
    """"""
    Get a restriction by ID.

    This endpoint retrieves a specific restriction by its ID.

    Args:
        id (int): The ID of the restriction to retrieve.

    Returns:
        JSON: The details of the restriction if found, or an error message if not.
    """"""
    restriction = Restriction.query.get(id)
    if restriction:
        return jsonify(restriction.to_json())
    return jsonify({""message"": ""Restriction not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,update_restriction,,"def update_restriction(id):
    """"""
    Update an existing restriction.

    This endpoint allows you to update the details of an existing restriction by providing the following fields:
    - name: The new name of the restriction.

    Args:
        id (int): The ID of the restriction to update.

    Returns:
        JSON: A message confirming the update, or an error message if the restriction was not found.
    """"""
    restriction = Restriction.query.get(id)
    if restriction:
        data = request.get_json()
        restriction.name = data['name']
        db.session.commit()
        return jsonify({""message"": ""Restriction updated""})
    return jsonify({""message"": ""Restriction not found""}), 404",
/Users/absonson/Projects/projeto11/2025-1A-T05-CC11-G02/src/relational_api/modules/routes.py,,delete_restriction,,"def delete_restriction(id):
    """"""
    Delete a restriction.

    This endpoint allows you to delete a restriction by providing the restriction's ID.

    Args:
        id (int): The ID of the restriction to delete.

    Returns:
        JSON: A message confirming the deletion, or an error message if the restriction was not found.
    """"""
    restriction = Restriction.query.get(id)
    if restriction:
        db.session.delete(restriction)
        db.session.commit()
        return jsonify({""message"": ""Restriction deleted""})
    return jsonify({""message"": ""Restriction not found""}), 404",
